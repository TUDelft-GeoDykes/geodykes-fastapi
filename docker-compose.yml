version: "3.9"

services:
  # Service for the application
  application:
    build:
      context: .
      dockerfile: ./Dockerfile
      args:
        - ENVIRONMENT=dev
    restart: always
    volumes:
      # Mount the application code into the container
      # This allows changes in the code to be reflected in the container without needing a rebuild
      - .:/code
    ports:
      # Expose port 8000 of the container to port 8000 on the host
      # This allows you to access the application at localhost:8000
      - 8000:8000
    depends_on:
      # Wait for the database to become available before starting the application
      db:
        condition: service_healthy
    environment:
      # Environment variables for debugging and database echo
      - DEBUG=true
      - DB_ECHO=true
    env_file:
      # Load environment variables from a file
      - .env-production
    
    # attempt to apply the database upgrade. If the upgrade command fails 
    # (for example, because the upgrade has already been applied), 
    # the true command will be executed, effectively ignoring the error.
    command: >
      sh -c "alembic upgrade head || true && python -m app"  

    networks:
      - geodykes-network

  # Service for the database
  db:
    image: postgres:14
    restart: always
    env_file:
      # Load environment variables from a file
      - .env-production
    ports:
    - "5432:5432"  # Expose port 5432 on the host to port 5432 on the container
    volumes:
      # Persist database data between container restarts
      # This volume stores the database data on the host machine to ensure data is not lost when the container is restarted
      - pgdata:/var/lib/postgresql/data
    healthcheck:
      test: [CMD-SHELL, pg_isready -U postgres -d postgres]
      interval: 1s
      timeout: 5s
      retries: 15
    networks:
      - geodykes-network

# Named volumes for the database
volumes:
  pgdata:

networks:
  geodykes-network:
    driver: bridge